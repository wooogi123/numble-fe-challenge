{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport * as React from 'react';\nimport useGameReducer from './useGameReducer';\nimport { useRequestAnimationFrame } from '../../hooks';\n\nconst useGame = () => {\n  _s();\n\n  const [state, dispatch] = useGameReducer();\n  const isStarted = React.useMemo(() => state.isStarted, [state]);\n  const isGameOver = React.useMemo(() => state.isGameOver, [state]);\n  const isClear = React.useMemo(() => state.isClear, [state]);\n  const elapsedTime = React.useRef(0);\n  useRequestAnimationFrame(deltaTime => {\n    if (!isStarted) return;\n    if (isGameOver) return;\n    if (isClear) return;\n    elapsedTime.current += deltaTime;\n\n    if (elapsedTime.current >= 100) {\n      dispatch({\n        type: 'tick',\n        payload: elapsedTime.current\n      });\n      elapsedTime.current = 0;\n    }\n  }, [isStarted, isGameOver]);\n  return {\n    state,\n    dispatch\n  };\n};\n\n_s(useGame, \"JDW9yrEOSIRoEpdfrcKHBoMmUgI=\", false, function () {\n  return [useGameReducer, useRequestAnimationFrame];\n});\n\nexport default useGame;\n/*\nconst initialState: State = {\n  remainingTime: 0,\n  stage: 0,\n  score: 0,\n  isStarted: false,\n  isGameOver: false,\n  isClear: false,\n};\n\ntype UseGameReturn = [\n  state: State,\n  dispatch: React.Dispatch<Action>,\n];\n\nconst useGame = (): UseGameReturn => {\n  const [state, dispatch] = React.useReducer(gameReducer, initialState);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log(state);\n    }\n  }, [state]);\n\n  return [state, dispatch];\n}\n\nexport default useGame;\n\nexport const gameReducer: React.Reducer<State, Action> = (state, action) => {\n  switch (action.type) {\n    case 'init': {\n      return {\n        remainingTime: INITIAL_TIME,\n        stage: 1,\n        score: 0,\n        isStarted: true,\n        isGameOver: false,\n        isClear: false,\n      };\n    }\n    case 'done': {\n      return initialState;\n    }\n    case 'tick': {\n      if (!state.isStarted) return state;\n\n      if (state.remainingTime < action.payload) {\n        return produce(state, {\n          remainingTime: 0,\n          isGameOver: true,\n          isClear: false,\n        });\n      }\n\n      const remainingTime = Math.max(Math.floor(state.remainingTime - action.payload), 0);\n      return produce(state, { remainingTime });\n    }\n    case 'nextStage': {\n      if (!state.isStarted) return state;\n      if (state.isGameOver) return state;\n      if (state.stage >= LAST_STAGE) return produce(state, { isClear: true });\n\n      return produce(state, {\n        remainingTime: INITIAL_TIME,\n        stage: state.stage + 1,\n        score: Math.pow(state.stage, 3) * state.remainingTime,\n      });\n    }\n    case 'deduct': {\n      if (!state.isStarted) return state;\n      if (state.isGameOver) return state;\n\n      if (state.remainingTime < DEDUCT_TIME) {\n        return produce(state, { remainingTime: 0, isGameOver: true });\n      }\n\n      return produce(state, {\n        remainingTime: state.remainingTime - DEDUCT_TIME,\n      });\n    }\n    default: {\n      throw new Error('invalid action');\n    }\n  };\n};\n\ninterface State {\n  remainingTime: number;\n  stage: number;\n  score: number;\n  isStarted: boolean;\n  isGameOver: boolean;\n  isClear: boolean;\n}\n\ntype Action =\n  | { type: 'init' }\n  | { type: 'done' }\n  | { type: 'tick', payload: number }\n  | { type: 'nextStage' }\n  | { type: 'deduct' }\n;\n\nconst produce = <S>(state: S, newState: Partial<S>): S =>\n  ({ ...state, ...newState });\n  */","map":{"version":3,"sources":["/Users/leejaeuk/Dev/playground/numble-1/src/features/game/useGame.ts"],"names":["React","useGameReducer","useRequestAnimationFrame","useGame","state","dispatch","isStarted","useMemo","isGameOver","isClear","elapsedTime","useRef","deltaTime","current","type","payload"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,SAASC,wBAAT,QAAyC,aAAzC;;AAOA,MAAMC,OAAO,GAAG,MAAM;AAAA;;AACpB,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBJ,cAAc,EAAxC;AAEA,QAAMK,SAAS,GAAGN,KAAK,CAACO,OAAN,CAAc,MAAMH,KAAK,CAACE,SAA1B,EAAqC,CAACF,KAAD,CAArC,CAAlB;AACA,QAAMI,UAAU,GAAGR,KAAK,CAACO,OAAN,CAAc,MAAMH,KAAK,CAACI,UAA1B,EAAsC,CAACJ,KAAD,CAAtC,CAAnB;AACA,QAAMK,OAAO,GAAGT,KAAK,CAACO,OAAN,CAAc,MAAMH,KAAK,CAACK,OAA1B,EAAmC,CAACL,KAAD,CAAnC,CAAhB;AAEA,QAAMM,WAAW,GAAGV,KAAK,CAACW,MAAN,CAAqB,CAArB,CAApB;AAEAT,EAAAA,wBAAwB,CAAEU,SAAD,IAAe;AACtC,QAAI,CAACN,SAAL,EAAgB;AAChB,QAAIE,UAAJ,EAAgB;AAChB,QAAIC,OAAJ,EAAa;AAEbC,IAAAA,WAAW,CAACG,OAAZ,IAAuBD,SAAvB;;AAEA,QAAIF,WAAW,CAACG,OAAZ,IAAuB,GAA3B,EAAgC;AAC9BR,MAAAA,QAAQ,CAAC;AAAES,QAAAA,IAAI,EAAE,MAAR;AAAgBC,QAAAA,OAAO,EAAEL,WAAW,CAACG;AAArC,OAAD,CAAR;AACAH,MAAAA,WAAW,CAACG,OAAZ,GAAsB,CAAtB;AACD;AACF,GAXuB,EAWrB,CAACP,SAAD,EAAYE,UAAZ,CAXqB,CAAxB;AAaA,SAAO;AACLJ,IAAAA,KADK;AAELC,IAAAA;AAFK,GAAP;AAID,CA1BD;;GAAMF,O;UACsBF,c,EAQ1BC,wB;;;AAmBF,eAAeC,OAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import * as React from 'react';\nimport useGameReducer from './useGameReducer';\nimport { useRequestAnimationFrame } from '../../hooks';\nimport {\n  INITIAL_TIME,\n  DEDUCT_TIME,\n  LAST_STAGE,\n} from './constants';\n\nconst useGame = () => {\n  const [state, dispatch] = useGameReducer();\n\n  const isStarted = React.useMemo(() => state.isStarted, [state]);\n  const isGameOver = React.useMemo(() => state.isGameOver, [state]);\n  const isClear = React.useMemo(() => state.isClear, [state]);\n\n  const elapsedTime = React.useRef<number>(0);\n\n  useRequestAnimationFrame((deltaTime) => {\n    if (!isStarted) return;\n    if (isGameOver) return;\n    if (isClear) return;\n\n    elapsedTime.current += deltaTime;\n\n    if (elapsedTime.current >= 100) {\n      dispatch({ type: 'tick', payload: elapsedTime.current });\n      elapsedTime.current = 0;\n    }\n  }, [isStarted, isGameOver]);\n\n  return {\n    state,\n    dispatch\n  };\n};\n\nexport default useGame;\n\n/*\nconst initialState: State = {\n  remainingTime: 0,\n  stage: 0,\n  score: 0,\n  isStarted: false,\n  isGameOver: false,\n  isClear: false,\n};\n\ntype UseGameReturn = [\n  state: State,\n  dispatch: React.Dispatch<Action>,\n];\n\nconst useGame = (): UseGameReturn => {\n  const [state, dispatch] = React.useReducer(gameReducer, initialState);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log(state);\n    }\n  }, [state]);\n\n  return [state, dispatch];\n}\n\nexport default useGame;\n\nexport const gameReducer: React.Reducer<State, Action> = (state, action) => {\n  switch (action.type) {\n    case 'init': {\n      return {\n        remainingTime: INITIAL_TIME,\n        stage: 1,\n        score: 0,\n        isStarted: true,\n        isGameOver: false,\n        isClear: false,\n      };\n    }\n    case 'done': {\n      return initialState;\n    }\n    case 'tick': {\n      if (!state.isStarted) return state;\n\n      if (state.remainingTime < action.payload) {\n        return produce(state, {\n          remainingTime: 0,\n          isGameOver: true,\n          isClear: false,\n        });\n      }\n\n      const remainingTime = Math.max(Math.floor(state.remainingTime - action.payload), 0);\n      return produce(state, { remainingTime });\n    }\n    case 'nextStage': {\n      if (!state.isStarted) return state;\n      if (state.isGameOver) return state;\n      if (state.stage >= LAST_STAGE) return produce(state, { isClear: true });\n\n      return produce(state, {\n        remainingTime: INITIAL_TIME,\n        stage: state.stage + 1,\n        score: Math.pow(state.stage, 3) * state.remainingTime,\n      });\n    }\n    case 'deduct': {\n      if (!state.isStarted) return state;\n      if (state.isGameOver) return state;\n\n      if (state.remainingTime < DEDUCT_TIME) {\n        return produce(state, { remainingTime: 0, isGameOver: true });\n      }\n\n      return produce(state, {\n        remainingTime: state.remainingTime - DEDUCT_TIME,\n      });\n    }\n    default: {\n      throw new Error('invalid action');\n    }\n  };\n};\n\ninterface State {\n  remainingTime: number;\n  stage: number;\n  score: number;\n  isStarted: boolean;\n  isGameOver: boolean;\n  isClear: boolean;\n}\n\ntype Action =\n  | { type: 'init' }\n  | { type: 'done' }\n  | { type: 'tick', payload: number }\n  | { type: 'nextStage' }\n  | { type: 'deduct' }\n;\n\nconst produce = <S>(state: S, newState: Partial<S>): S =>\n  ({ ...state, ...newState });\n  */\n"]},"metadata":{},"sourceType":"module"}