{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport * as React from 'react';\nimport { INITIAL_TIME, DEDUCT_TIME, LAST_STAGE } from './constants';\nconst initialState = {\n  remainingTime: 0,\n  stage: 0,\n  score: 0,\n  isStarted: false,\n  isGameOver: false,\n  isClear: false\n};\n\nconst useGame = () => {\n  _s();\n\n  const [state, dispatch] = React.useReducer(gameReducer, initialState);\n  React.useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log(state);\n    }\n  }, [state]);\n  return [state, dispatch];\n};\n\n_s(useGame, \"bgCdjuTOmPdSBRwTap80EFd9Y3U=\");\n\nexport default useGame;\nexport const gameReducer = (state, action) => {\n  switch (action.type) {\n    case 'init':\n      {\n        return {\n          remainingTime: INITIAL_TIME,\n          stage: 1,\n          score: 0,\n          isStarted: true,\n          isGameOver: false,\n          isClear: false\n        };\n      }\n\n    case 'done':\n      {\n        return initialState;\n      }\n\n    case 'tick':\n      {\n        if (!state.isStarted) return state;\n\n        if (state.remainingTime < action.payload) {\n          return produce(state, {\n            remainingTime: 0,\n            isGameOver: true,\n            isClear: false\n          });\n        }\n\n        const remainingTime = Math.max(Math.floor(state.remainingTime - action.payload), 0);\n        return produce(state, {\n          remainingTime\n        });\n      }\n\n    case 'nextStage':\n      {\n        if (!state.isStarted) return state;\n        if (state.isGameOver) return state;\n        if (state.stage >= LAST_STAGE) return produce(state, {\n          isClear: true\n        });\n        return produce(state, {\n          remainingTime: INITIAL_TIME,\n          stage: state.stage + 1,\n          score: Math.pow(state.stage, 3) * state.remainingTime\n        });\n      }\n\n    case 'deduct':\n      {\n        if (!state.isStarted) return state;\n        if (state.isGameOver) return state;\n\n        if (state.remainingTime < DEDUCT_TIME) {\n          return produce(state, {\n            remainingTime: 0,\n            isGameOver: true\n          });\n        }\n\n        return produce(state, {\n          remainingTime: state.remainingTime - DEDUCT_TIME\n        });\n      }\n\n    default:\n      {\n        throw new Error('invalid action');\n      }\n  }\n\n  ;\n};\n\nconst produce = (state, newState) => ({ ...state,\n  ...newState\n});","map":{"version":3,"sources":["/Users/leejaeuk/Dev/playground/numble-1/src/features/game/useGame.ts"],"names":["React","INITIAL_TIME","DEDUCT_TIME","LAST_STAGE","initialState","remainingTime","stage","score","isStarted","isGameOver","isClear","useGame","state","dispatch","useReducer","gameReducer","useEffect","process","env","NODE_ENV","console","log","action","type","payload","produce","Math","max","floor","pow","Error","newState"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  INITIAL_TIME,\n  DEDUCT_TIME,\n  LAST_STAGE,\n} from './constants';\n\nconst initialState: State = {\n  remainingTime: 0,\n  stage: 0,\n  score: 0,\n  isStarted: false,\n  isGameOver: false,\n  isClear: false,\n};\n\ntype UseGameReturn = [\n  state: State,\n  dispatch: React.Dispatch<Action>,\n];\n\nconst useGame = (): UseGameReturn => {\n  const [state, dispatch] = React.useReducer(gameReducer, initialState);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log(state);\n    }\n  }, [state]);\n\n  return [state, dispatch];\n}\n\nexport default useGame;\n\nexport const gameReducer: React.Reducer<State, Action> = (state, action) => {\n  switch (action.type) {\n    case 'init': {\n      return {\n        remainingTime: INITIAL_TIME,\n        stage: 1,\n        score: 0,\n        isStarted: true,\n        isGameOver: false,\n        isClear: false,\n      };\n    }\n    case 'done': {\n      return initialState;\n    }\n    case 'tick': {\n      if (!state.isStarted) return state;\n\n      if (state.remainingTime < action.payload) {\n        return produce(state, {\n          remainingTime: 0,\n          isGameOver: true,\n          isClear: false,\n        });\n      }\n\n      const remainingTime = Math.max(Math.floor(state.remainingTime - action.payload), 0);\n      return produce(state, { remainingTime });\n    }\n    case 'nextStage': {\n      if (!state.isStarted) return state;\n      if (state.isGameOver) return state;\n      if (state.stage >= LAST_STAGE) return produce(state, { isClear: true });\n\n      return produce(state, {\n        remainingTime: INITIAL_TIME,\n        stage: state.stage + 1,\n        score: Math.pow(state.stage, 3) * state.remainingTime,\n      });\n    }\n    case 'deduct': {\n      if (!state.isStarted) return state;\n      if (state.isGameOver) return state;\n\n      if (state.remainingTime < DEDUCT_TIME) {\n        return produce(state, { remainingTime: 0, isGameOver: true });\n      }\n\n      return produce(state, {\n        remainingTime: state.remainingTime - DEDUCT_TIME,\n      });\n    }\n    default: {\n      throw new Error('invalid action');\n    }\n  };\n};\n\ninterface State {\n  remainingTime: number;\n  stage: number;\n  score: number;\n  isStarted: boolean;\n  isGameOver: boolean;\n  isClear: boolean;\n}\n\ntype Action =\n  | { type: 'init' }\n  | { type: 'done' }\n  | { type: 'tick', payload: number }\n  | { type: 'nextStage' }\n  | { type: 'deduct' }\n;\n\nconst produce = <S>(state: S, newState: Partial<S>): S =>\n  ({ ...state, ...newState });\n"]},"metadata":{},"sourceType":"module"}